// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class USRLG_v1detailsEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1detailsEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1detailsEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1detailsEvent", id.toString(), this);
  }

  static load(id: string): USRLG_v1detailsEvent | null {
    return store.get("USRLG_v1detailsEvent", id) as USRLG_v1detailsEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get ExchangeAddress(): Bytes {
    let value = this.get("ExchangeAddress");
    return value.toBytes();
  }

  set ExchangeAddress(value: Bytes) {
    this.set("ExchangeAddress", Value.fromBytes(value));
  }

  get TokenAdddress(): Bytes {
    let value = this.get("TokenAdddress");
    return value.toBytes();
  }

  set TokenAdddress(value: Bytes) {
    this.set("TokenAdddress", Value.fromBytes(value));
  }

  get LiqRed(): BigInt {
    let value = this.get("LiqRed");
    return value.toBigInt();
  }

  set LiqRed(value: BigInt) {
    this.set("LiqRed", Value.fromBigInt(value));
  }

  get ethRec(): BigInt {
    let value = this.get("ethRec");
    return value.toBigInt();
  }

  set ethRec(value: BigInt) {
    this.set("ethRec", Value.fromBigInt(value));
  }

  get tokenRec(): BigInt {
    let value = this.get("tokenRec");
    return value.toBigInt();
  }

  set tokenRec(value: BigInt) {
    this.set("tokenRec", Value.fromBigInt(value));
  }

  get func(): Bytes {
    let value = this.get("func");
    return value.toBytes();
  }

  set func(value: Bytes) {
    this.set("func", Value.fromBytes(value));
  }
}

export class USRLG_v1LetsWithdrawonlyERCCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1LetsWithdrawonlyERCCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1LetsWithdrawonlyERCCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1LetsWithdrawonlyERCCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1LetsWithdrawonlyERCCall | null {
    return store.get(
      "USRLG_v1LetsWithdrawonlyERCCall",
      id
    ) as USRLG_v1LetsWithdrawonlyERCCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get LiquidityTokenSold(): BigInt {
    let value = this.get("LiquidityTokenSold");
    return value.toBigInt();
  }

  set LiquidityTokenSold(value: BigInt) {
    this.set("LiquidityTokenSold", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class USRLG_v1LetsWithdrawonlyETHCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1LetsWithdrawonlyETHCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1LetsWithdrawonlyETHCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1LetsWithdrawonlyETHCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1LetsWithdrawonlyETHCall | null {
    return store.get(
      "USRLG_v1LetsWithdrawonlyETHCall",
      id
    ) as USRLG_v1LetsWithdrawonlyETHCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get LiquidityTokenSold(): BigInt {
    let value = this.get("LiquidityTokenSold");
    return value.toBigInt();
  }

  set LiquidityTokenSold(value: BigInt) {
    this.set("LiquidityTokenSold", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class USRLG_v1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1destructCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1destructCall | null {
    return store.get("USRLG_v1destructCall", id) as USRLG_v1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1initializeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1initializeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1initializeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1initializeCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1initializeCall | null {
    return store.get(
      "USRLG_v1initializeCall",
      id
    ) as USRLG_v1initializeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1initialize1Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1initialize1Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1initialize1Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1initialize1Call", id.toString(), this);
  }

  static load(id: string): USRLG_v1initialize1Call | null {
    return store.get(
      "USRLG_v1initialize1Call",
      id
    ) as USRLG_v1initialize1Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1setnewUniSwapFactoryAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1setnewUniSwapFactoryAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1setnewUniSwapFactoryAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1setnewUniSwapFactoryAddressCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1setnewUniSwapFactoryAddressCall | null {
    return store.get(
      "USRLG_v1setnewUniSwapFactoryAddressCall",
      id
    ) as USRLG_v1setnewUniSwapFactoryAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1setnewdzgoodwillAddressCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1setnewdzgoodwillAddressCall | null {
    return store.get(
      "USRLG_v1setnewdzgoodwillAddressCall",
      id
    ) as USRLG_v1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1setnewgoodwillCall | null {
    return store.get(
      "USRLG_v1setnewgoodwillCall",
      id
    ) as USRLG_v1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1toggleContractActiveCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1toggleContractActiveCall | null {
    return store.get(
      "USRLG_v1toggleContractActiveCall",
      id
    ) as USRLG_v1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1transferOwnershipCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1transferOwnershipCall | null {
    return store.get(
      "USRLG_v1transferOwnershipCall",
      id
    ) as USRLG_v1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class USRLG_v1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1withdrawCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1withdrawCall | null {
    return store.get("USRLG_v1withdrawCall", id) as USRLG_v1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USRLG_v1withdrawERC20TokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USRLG_v1withdrawERC20TokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USRLG_v1withdrawERC20TokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USRLG_v1withdrawERC20TokenCall", id.toString(), this);
  }

  static load(id: string): USRLG_v1withdrawERC20TokenCall | null {
    return store.get(
      "USRLG_v1withdrawERC20TokenCall",
      id
    ) as USRLG_v1withdrawERC20TokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USALV2_GERC20TokenHoldingsOnConversionEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GERC20TokenHoldingsOnConversionEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GERC20TokenHoldingsOnConversionEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "USALV2_GERC20TokenHoldingsOnConversionEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): USALV2_GERC20TokenHoldingsOnConversionEvent | null {
    return store.get(
      "USALV2_GERC20TokenHoldingsOnConversionEvent",
      id
    ) as USALV2_GERC20TokenHoldingsOnConversionEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get param0(): BigInt {
    let value = this.get("param0");
    return value.toBigInt();
  }

  set param0(value: BigInt) {
    this.set("param0", Value.fromBigInt(value));
  }
}

export class USALV2_GLiquidityTokensEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GLiquidityTokensEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GLiquidityTokensEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GLiquidityTokensEvent", id.toString(), this);
  }

  static load(id: string): USALV2_GLiquidityTokensEvent | null {
    return store.get(
      "USALV2_GLiquidityTokensEvent",
      id
    ) as USALV2_GLiquidityTokensEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get param0(): BigInt {
    let value = this.get("param0");
    return value.toBigInt();
  }

  set param0(value: BigInt) {
    this.set("param0", Value.fromBigInt(value));
  }
}

export class USALV2_GOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): USALV2_GOwnershipTransferredEvent | null {
    return store.get(
      "USALV2_GOwnershipTransferredEvent",
      id
    ) as USALV2_GOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class USALV2_GLetsInvestCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GLetsInvestCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GLetsInvestCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GLetsInvestCall", id.toString(), this);
  }

  static load(id: string): USALV2_GLetsInvestCall | null {
    return store.get(
      "USALV2_GLetsInvestCall",
      id
    ) as USALV2_GLetsInvestCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class USALV2_GdepositETHCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GdepositETHCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GdepositETHCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GdepositETHCall", id.toString(), this);
  }

  static load(id: string): USALV2_GdepositETHCall | null {
    return store.get(
      "USALV2_GdepositETHCall",
      id
    ) as USALV2_GdepositETHCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USALV2_GrenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GrenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GrenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GrenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): USALV2_GrenounceOwnershipCall | null {
    return store.get(
      "USALV2_GrenounceOwnershipCall",
      id
    ) as USALV2_GrenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USALV2_GtransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GtransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GtransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GtransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): USALV2_GtransferOwnershipCall | null {
    return store.get(
      "USALV2_GtransferOwnershipCall",
      id
    ) as USALV2_GtransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class USALV2_GwithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GwithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GwithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GwithdrawCall", id.toString(), this);
  }

  static load(id: string): USALV2_GwithdrawCall | null {
    return store.get("USALV2_GwithdrawCall", id) as USALV2_GwithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class USALV2_GwithdrawERC20TokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save USALV2_GwithdrawERC20TokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save USALV2_GwithdrawERC20TokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("USALV2_GwithdrawERC20TokenCall", id.toString(), this);
  }

  static load(id: string): USALV2_GwithdrawERC20TokenCall | null {
    return store.get(
      "USALV2_GwithdrawERC20TokenCall",
      id
    ) as USALV2_GwithdrawERC20TokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1OwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1OwnershipTransferredEvent | null {
    return store.get(
      "UV2_ZO_G_V2_1OwnershipTransferredEvent",
      id
    ) as UV2_ZO_G_V2_1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UV2_ZO_G_V2_1ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1ZapOutCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1ZapOutCall | null {
    return store.get(
      "UV2_ZO_G_V2_1ZapOutCall",
      id
    ) as UV2_ZO_G_V2_1ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1ZapOut2PairTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1ZapOut2PairTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1ZapOut2PairTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1ZapOut2PairTokenCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1ZapOut2PairTokenCall | null {
    return store.get(
      "UV2_ZO_G_V2_1ZapOut2PairTokenCall",
      id
    ) as UV2_ZO_G_V2_1ZapOut2PairTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get amountA(): BigInt {
    let value = this.get("amountA");
    return value.toBigInt();
  }

  set amountA(value: BigInt) {
    this.set("amountA", Value.fromBigInt(value));
  }

  get amountB(): BigInt {
    let value = this.get("amountB");
    return value.toBigInt();
  }

  set amountB(value: BigInt) {
    this.set("amountB", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall",
      id.toString(),
      this
    );
  }

  static load(id: string): UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall | null {
    return store.get(
      "UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall",
      id
    ) as UV2_ZO_G_V2_1ZapOut2PairTokenWithPermitCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get v(): i32 {
    let value = this.get("v");
    return value.toI32();
  }

  set v(value: i32) {
    this.set("v", Value.fromI32(value));
  }

  get r(): Bytes {
    let value = this.get("r");
    return value.toBytes();
  }

  set r(value: Bytes) {
    this.set("r", Value.fromBytes(value));
  }

  get s(): Bytes {
    let value = this.get("s");
    return value.toBytes();
  }

  set s(value: Bytes) {
    this.set("s", Value.fromBytes(value));
  }

  get amountA(): BigInt {
    let value = this.get("amountA");
    return value.toBigInt();
  }

  set amountA(value: BigInt) {
    this.set("amountA", Value.fromBigInt(value));
  }

  get amountB(): BigInt {
    let value = this.get("amountB");
    return value.toBigInt();
  }

  set amountB(value: BigInt) {
    this.set("amountB", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1ZapOutWithPermitCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1ZapOutWithPermitCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1ZapOutWithPermitCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1ZapOutWithPermitCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1ZapOutWithPermitCall | null {
    return store.get(
      "UV2_ZO_G_V2_1ZapOutWithPermitCall",
      id
    ) as UV2_ZO_G_V2_1ZapOutWithPermitCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get v(): i32 {
    let value = this.get("v");
    return value.toI32();
  }

  set v(value: i32) {
    this.set("v", Value.fromI32(value));
  }

  get r(): Bytes {
    let value = this.get("r");
    return value.toBytes();
  }

  set r(value: Bytes) {
    this.set("r", Value.fromBytes(value));
  }

  get s(): Bytes {
    let value = this.get("s");
    return value.toBytes();
  }

  set s(value: Bytes) {
    this.set("s", Value.fromBytes(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1inCaseTokengetsStuckCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1inCaseTokengetsStuckCall | null {
    return store.get(
      "UV2_ZO_G_V2_1inCaseTokengetsStuckCall",
      id
    ) as UV2_ZO_G_V2_1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1renounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1renounceOwnershipCall | null {
    return store.get(
      "UV2_ZO_G_V2_1renounceOwnershipCall",
      id
    ) as UV2_ZO_G_V2_1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1setnewgoodwillCall | null {
    return store.get(
      "UV2_ZO_G_V2_1setnewgoodwillCall",
      id
    ) as UV2_ZO_G_V2_1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1toggleContractActiveCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1toggleContractActiveCall | null {
    return store.get(
      "UV2_ZO_G_V2_1toggleContractActiveCall",
      id
    ) as UV2_ZO_G_V2_1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UV2_ZO_G_V2_1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1transferOwnershipCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1transferOwnershipCall | null {
    return store.get(
      "UV2_ZO_G_V2_1transferOwnershipCall",
      id
    ) as UV2_ZO_G_V2_1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UV2_ZO_G_V2_1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UV2_ZO_G_V2_1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UV2_ZO_G_V2_1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UV2_ZO_G_V2_1withdrawCall", id.toString(), this);
  }

  static load(id: string): UV2_ZO_G_V2_1withdrawCall | null {
    return store.get(
      "UV2_ZO_G_V2_1withdrawCall",
      id
    ) as UV2_ZO_G_V2_1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}
